use alloc::{boxed::Box, vec, vec::Vec};

use ostd::early_println;

use crate::device::crypto::{device::CryptoDevice, header::*, session::*};

pub struct AKCipherTest{}

impl AKCipherTest {
    fn encrypt_rsa(
        device: &CryptoDevice,
        key: &[u8],
        origin_data: Vec<u8>,
        encrypted_len: u32,
        padding_algo: RsaPaddingAlgo,
        hash_algo: RsaHashAlgo,
        key_type: AkcipherKeyType,
    ) -> Box<[u8]> {
        let mut flf = AkcipherCreateSessionFlf::new(key_type);
        flf.set_rsa(padding_algo, hash_algo);
        let encrypt_session = CryptoSession::<AkcipherSession>::new(
            &device,
            &mut flf,
            &mut AkcipherCreateSessionVlf { //len should be (<= ?) 24 ?
                key: key.into(),
            },
        )
        .unwrap();
        let encrypt_out = encrypt_session
            .basic_request(
                AkcipherOpcode::ENCRYPT,
                &mut AkcipherDataFlf::new(encrypted_len),
                &AkcipherDataVlfIn {
                    src_data: origin_data.into_boxed_slice(),
                },
            )
            .unwrap();
        early_println!("encrypt output: {:?}", encrypt_out);
        let encrypted_data = encrypt_out.dst_data;
        encrypt_session.destroy().unwrap();
        encrypted_data
    }

    fn decrypt_rsa(
        device: &CryptoDevice,
        key: &str,
        encrypted_data: Vec<u8>,
        decrypted_len: u32,
        padding_algo: RsaPaddingAlgo,
        hash_algo: RsaHashAlgo,
        key_type: AkcipherKeyType,
    ) -> Box<[u8]> {
        let mut flf = AkcipherCreateSessionFlf::new(key_type);
        flf.set_rsa(padding_algo, hash_algo);
        let decrypt_session = CryptoSession::<AkcipherSession>::new(
            &device,
            &mut flf,
            &mut AkcipherCreateSessionVlf {
                key: key.as_bytes().into(),
            },
        )
        .unwrap();
        let decrypt_out = decrypt_session
            .basic_request(
                AkcipherOpcode::DECRYPT,
                &mut AkcipherDataFlf::new(decrypted_len),
                &AkcipherDataVlfIn {
                    src_data: encrypted_data.into_boxed_slice(),
                },
            )
            .unwrap();
        early_println!("decrypt output: {:?}", decrypt_out);
        let decrypted_data = decrypt_out.dst_data;
        decrypt_session.destroy().unwrap();
        decrypted_data
    }

    pub fn test1(device: &CryptoDevice) {
        early_println!("testcase1 from akcipherTest!");
    }

    pub fn test_rsa_encrypt_decrypt(device: &CryptoDevice) {
        let key = "";
        let a = b"\x30\x82\x02\x5D\x02\x01\x00\x02\x81\x81\x00\xA6\xCB\x6D\xE2\x7C\xDF\x69\x8B\x92\xCE\xE0\xC4\x77\x2D\x48\x54\xD2\xFF\x8B\x66\x6B\xFB\xF0\x7F\xA3\x77\xE4\x7A\x90\x57\x16\x65\xFD\x6A\x5B\x8C\x9F\x29\x30\xE4\xAF\x28\xE3\x2E\x52\x21\x62\xAC\x66\xCD\x70\xAA\x1B\x26\x88\x8E\x3E\xEE\x26\x8A\x2B\x59\xFE\xCA\x7E\x4C\x69\x3A\xE2\x6B\x87\x8B\x30\x27\xF5\x86\x84\x29\xFD\x8B\xEB\xE8\x5B\xFE\xD3\xB0\xE5\xDF\x0E\x9D\x72\xAA\xB1\x21\x69\x02\xB0\x74\xFA\x2D\xD5\x90\x01\xEF\xC4\xCD\xB1\xE7\x30\x5F\xF4\x8E\x0D\x31\x0C\x0A\x4F\x79\x8E\xFC\x75\x8F\x97\x03\xC4\xF9\x6C\x93\x02\x03\x01\x00\x01\x02\x81\x81\x00\x83\x67\xE1\xBA\x7E\x06\xC5\x70\x60\xC8\xFB\xEB\xCC\xB8\xB0\x33\xA3\xC8\x10\x5B\x30\xD7\xDC\x31\xB2\xE7\xD1\xE9\x7D\xAE\x1E\xC7\x5B\x4F\x5F\xB0\xF9\xF3\xC9\xC1\x60\xFE\x25\x7D\x68\xD7\x44\x95\xEE\xA8\x0C\x0A\xF8\x38\xF3\x7C\x9D\xB7\xA2\x45\x58\xC2\x1E\x28\xC4\x9D\x57\x47\x0B\x00\x2D\x90\xA3\x83\xCA\xEB\xB5\x82\x1A\x59\x58\x3D\x15\x50\x2F\x00\x12\xC9\x23\x5F\x80\x6C\x62\xC9\x7F\x1E\x3C\xAF\xBC\x72\x11\x8F\xCF\x60\x74\x31\x68\x12\x58\x01\xE0\x6C\xC7\x29\x3C\xDE\x64\xD2\x41\x33\x9A\xAD\x51\x6E\x7B\xCC\x10\x81\x02\x41\x00\xD0\x0E\x8D\xE6\x5F\x7C\x32\x09\x4B\x73\x2A\x56\x28\xCE\xFE\xDC\x35\xED\x79\x6B\x7C\xEA\x62\x97\x61\x45\x45\xDF\x71\xD8\xDB\xC6\x7E\xA1\x45\x65\x53\x4B\xFC\x9B\xC5\xF1\xA6\x80\x23\x92\x27\x18\x9C\x2D\x49\x39\x24\xA5\xBD\x64\x64\x11\x69\x53\x32\x01\xD6\xE5\x02\x41\x00\xCD\x3A\xC8\x81\xCC\x47\xAA\x77\x6A\x98\x29\xC0\xE5\x29\xE3\xD0\xDB\xB5\xA4\x3C\x36\x68\x42\x57\x83\x41\xA0\x51\xDA\xFA\xF4\xF6\x16\x4F\x2D\xC0\xE7\x2A\x3B\xD3\xB3\x3F\x8B\x2F\x84\xA6\xCF\x35\xF0\x78\x1E\x7C\x46\x6E\x67\x7F\xF8\xE5\x53\xDE\x5C\x92\xC6\x17\x02\x40\x74\x4F\x3E\x9A\x83\xD4\xAD\x30\x2F\x02\xB1\xAF\x3A\xDF\x04\xF0\xDC\x20\xE6\x98\xE5\x5B\x2E\x44\x8C\x37\x2A\xA9\x90\x3E\x78\x16\x4E\x22\x1F\xE6\x56\x1B\x8B\x9B\x15\x9C\x52\xC5\x1D\x9D\x8D\xC7\x9F\x3F\x5D\xC8\xD9\x28\xE2\x68\xA5\xDC\x69\xF1\xFD\x69\xB3\xD5\x02\x41\x00\xB7\xAC\xEA\x92\xB0\x5F\x5B\x83\x70\xD5\x2A\x59\x47\x40\x0C\x72\x7A\x90\xC0\xA2\x5B\x17\x48\x78\xC6\x32\x4F\xE7\xB2\x92\x73\xF6\x62\xD5\x0E\x5F\xDD\x04\x01\x73\x60\xB3\x78\x40\x58\xFA\x69\xED\x1E\x80\x82\xD8\x3A\xB8\xC8\xCC\xD1\xD7\x7D\x0E\x3F\xCF\xE4\x95\x02\x40\x4F\x79\xB9\x00\xCE\x91\x85\x83\x35\x73\xBB\xA5\x4E\x1B\x1D\x15\x7E\xDF\xE8\xC3\x7F\xC3\x28\xD2\x52\x0C\xCE\x7C\xC8\x04\xA9\xA2\x8B\x58\xD9\x37\x62\x6E\xBA\xD5\xFD\xE9\x65\x34\xBB\xEE\x4E\x29\x2E\xE8\x01\x0C\xFF\xC8\xDB\x1E\x54\x6C\x99\xFC\x51\x7B\x4C\x67";
        let origin_data = vec![1, 2, 3, 4, 5, 6, 7, 8];
        let encrypted_data = Self::encrypt_rsa(
            device,
            a,
            origin_data.clone(),
            128,
            RsaPaddingAlgo::RSA_PKCS1_PADDING,
            RsaHashAlgo::RSA_MD5,
            AkcipherKeyType::AKCIPHER_KEY_TYPE_PRIVATE,
        );
        let decrypted_data = Self::decrypt_rsa(
            device,
            key,
            encrypted_data.to_vec(),
            8,
            RsaPaddingAlgo::RSA_PKCS1_PADDING,
            RsaHashAlgo::RSA_MD4,
            AkcipherKeyType::AKCIPHER_KEY_TYPE_PUBLIC,
        );
        assert_eq!(origin_data, decrypted_data.to_vec());
        early_println!("test_rsa_encrypt_decrypt passed!");
    }

    
}